import{_ as e,c as s,d as c,o as n}from"./app-BN04xNHl.js";const r={};function d(o,a){return n(),s("div",null,[...a[0]||(a[0]=[c('<p>优化 Webpack 的构建速度是一个常见的需求，现在主流的思想都是 <mark><strong>以存储空间换构建时间</strong></mark>，下面是一些常见的优化策略：</p><h3 id="_1、代码分割-splitchrunk-持久化缓存" tabindex="-1"><a class="header-anchor" href="#_1、代码分割-splitchrunk-持久化缓存"><span>1、代码分割 SplitChrunk + 持久化缓存</span></a></h3><p>将布局组件、UI 组件、Eslint、babel-loader、DLL 文件、体积较大的依赖包等不经常变化的代码进行合理的 <code>churnk</code> 分割。</p><p>利用文件缓存加速二次打包。WebPack 通过判断文件是否发生变化，来判断是否需要重新编译。</p><p>同时需要注意持久化缓存的 Hash （文件指纹）生成策略、颗粒度也会影响构建速度。越复杂的 Hash 值，增量构建的范围也越小，越利于缓存命中，但是会增加构建时间。</p><h3 id="_2、开启多线程并行构建" tabindex="-1"><a class="header-anchor" href="#_2、开启多线程并行构建"><span>2、开启多线程并行构建</span></a></h3><p>可以利用多进程开启并行构建，充分利用多核 CPU 资源，提高构建速度。</p><p>但是进程的启动也是有时间开销的，需要根据代码规模酌情考虑。</p><h3 id="_3、文件排除-include-exclude" tabindex="-1"><a class="header-anchor" href="#_3、文件排除-include-exclude"><span>3、文件排除 Include / Exclude</span></a></h3><p>在 <code>module.rules</code> 中给规则组配置 <code>Include / Exclude</code> 来排除掉不需要编译的目录和文件，限制 loader 的作用范围。</p><h3 id="_4、使用-oneof-精准匹配" tabindex="-1"><a class="header-anchor" href="#_4、使用-oneof-精准匹配"><span>4、使用 <code>oneOf()</code> 精准匹配</span></a></h3><p><code>oneOf</code> 的作用就是，配置了多个规则组情况下，只要匹配了一个 Rule，就不再继续匹配其他的 Rule。</p><p>与之配合的是，我们可以通过调整规则组的匹配规则：</p><ul><li>调整匹配规则，尽量缩小匹配文件的类型范围</li><li>尽量将用来处理同一类型文件的 Loader 合并到一个规则组中。</li><li>控制规则组的数量</li></ul><h3 id="_5、模块解析-resolve-提高资源匹配速度" tabindex="-1"><a class="header-anchor" href="#_5、模块解析-resolve-提高资源匹配速度"><span>5、模块解析 resolve，提高资源匹配速度</span></a></h3><ul><li>使用 <code>resolve.alias</code> 配置别名，加快模块的查找速度；</li><li>使用 <code>‌resolve.extensions</code> 指定扩展名、指定查找的文件类型；</li><li>使用 <code>‌resolve.modules</code> 指定搜索目录。</li></ul><h3 id="_6、调整-sourcemap-策略的颗粒度" tabindex="-1"><a class="header-anchor" href="#_6、调整-sourcemap-策略的颗粒度"><span>6、调整 SourceMap 策略的颗粒度</span></a></h3><p>关闭或者使用低精度的 SourceMap 生成策略，打包速度更快</p><h3 id="_7、调整文件指纹-hash-的生成策略" tabindex="-1"><a class="header-anchor" href="#_7、调整文件指纹-hash-的生成策略"><span>7、调整文件指纹 hash 的生成策略</span></a></h3><p>Webpack 通过为文件名添加唯一的哈希值（hash），可以确保文件内容发生变化时，文件名也会随之改变，从而强制浏览器重新加载最新的文件，而不是使用缓存中的旧版本。</p><p>文件指纹生成策略越精细时：增量构建的变化范围也越小，生成的补丁文件颗粒度也越细，意味着对缓存的影响越小，但同时构建速度也越慢。</p><h3 id="_8、dll-技术" tabindex="-1"><a class="header-anchor" href="#_8、dll-技术"><span>8、DLL 技术</span></a></h3><p>在前端构建优化中，DLL（Dynamic Link Library）技术主要用于将不经常变更的第三方依赖预编译为单独文件，进而使用持久化缓存，从而显著提升构建速度。</p><p>但是 DLL 文件有些弊端，比如配置复杂、不支持 Tree Shaking。取而代之的解决方案是 WebPack 5 的代码分割和持久化缓存。</p><h3 id="_9、关闭-devserver" tabindex="-1"><a class="header-anchor" href="#_9、关闭-devserver"><span>9、关闭 devServer</span></a></h3><p>生产环境不需要启用开发服务器</p>',26)])])}const l=e(r,[["render",d]]),i=JSON.parse('{"path":"/notes/Webpack/1nxo855s/","title":"3. 如何提高生产环境的构建速度？ | Webpack","lang":"zh-CN","frontmatter":{"title":"3. 如何提高生产环境的构建速度？","createTime":"2025/03/15 14:24:59","permalink":"/notes/Webpack/1nxo855s/","tags":["Webpack","构建"]},"readingTime":{"minutes":2.65,"words":794},"git":{"createdTime":1750332430000,"updatedTime":1764524144000,"contributors":[{"name":"kangkang shang","username":"","email":"535634238@qq.com","commits":5,"avatar":"https://gravatar.com/avatar/899a2a8091fc73ff6879f8a45f98a5a42ca8b9665bca19ce8af3a144e416ed11?d=retro"}],"changelog":[{"hash":"37a5215b25a66c978fe447e5ce9d1d1acc9adaad","time":1764524144000,"email":"535634238@qq.com","author":"kangkang shang","message":"docs: 更新文档结构和内容"},{"hash":"124f72594441111abcb00084f511da1725f64285","time":1750420183000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"b7204c728e1575aed54a2781d9238c2e6940c6d8","time":1750335322000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"d359cf10bc5908e7b59c9e4170ff08f8c4ef0aca","time":1750333500000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"504e9c6a8251486de700690b6e488c4dc0f79fc7","time":1750332430000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"}]},"filePathRelative":"notes/Webpack/99.面试题/3.Webpack 如何提高生产环境的构建速度？.md","headers":[],"bulletin":false}');export{l as comp,i as data};
