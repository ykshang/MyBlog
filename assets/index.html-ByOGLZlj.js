import{_ as i,c as a,d as e,o as n}from"./app-BN04xNHl.js";const h={};function l(t,s){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h2 id="哈希如何生成的" tabindex="-1"><a class="header-anchor" href="#哈希如何生成的"><span>哈希如何生成的</span></a></h2><p>Webpack 生成哈希值的过程可以简化为以下关键步骤：</p><h3 id="内容准备阶段" tabindex="-1"><a class="header-anchor" href="#内容准备阶段"><span>内容准备阶段</span></a></h3><ul><li>收集目标文件的所有内容（包括代码和依赖关系）</li><li>对模块内容进行标准化处理（移除空格/注释等不影响功能的差异）</li></ul><h3 id="哈希计算阶段" tabindex="-1"><a class="header-anchor" href="#哈希计算阶段"><span>哈希计算阶段</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-javascript"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 简化的哈希计算逻辑</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> crypto</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> require</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">crypto</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> generateHash</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">content</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> crypto</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">createHash</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">md5</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 使用MD5算法</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">update</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">content</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输入内容</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">digest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hex</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输出16进制格式</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">substring</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 取前8位作为短哈希</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="输出应用阶段" tabindex="-1"><a class="header-anchor" href="#输出应用阶段"><span>输出应用阶段</span></a></h3><ul><li>将生成的哈希插入文件名：<code>main.[hash].js</code> → <code>main.a1b2c3d4.js</code></li><li>不同哈希类型区别： <ul><li><code>[hash]</code>：基于整个构建</li><li><code>[chunkhash]</code>：基于代码块内容</li><li><code>[contenthash]</code>：基于文件完整内容</li></ul></li></ul><p><strong>典型示例</strong>：</p><ol><li>文件内容：<code>console.log(&quot;Hello&quot;)</code></li><li>计算 MD5：<code>2ef7bde...</code>（完整哈希）</li><li>截取使用：<code>2ef7bde8</code></li><li>生成文件：<code>main.2ef7bde8.js</code></li></ol><h2 id="什么是哈希碰撞" tabindex="-1"><a class="header-anchor" href="#什么是哈希碰撞"><span>什么是哈希碰撞</span></a></h2><p>哈希碰撞是指两个文件根据文件特征计算出的哈希值相同。如果文件本身重名，可能会导致严重的缓存和版本管理问题。</p><p>如果文件内容相同，一定会产生哈希碰撞，但是一般不会影响代码运行。</p><p>如果内容不相同，产生哈希碰撞的概率极低，如果遇到了，就可能会导致代码运行出错。</p><h2 id="哈希碰撞的危害" tabindex="-1"><a class="header-anchor" href="#哈希碰撞的危害"><span>哈希碰撞的危害</span></a></h2><p>哈希碰撞主要影响 Webpack 的 <code>emitAssets</code> 阶段，这个阶段会输出 bundle 到指定目录下。这时候如果遇到了完全同名的 bundle，可能会发生 <mark><strong>内容覆盖</strong></mark> 的现象，即 <strong>后生成的 bundle 会覆盖之前生成的 bundle</strong>，最终只剩下一份。如果这些 bundle 的内容不相同，就意味着依赖这些 bundle 的代码在运行时可能会出现非常严重的问题。</p><h2 id="如何解决" tabindex="-1"><a class="header-anchor" href="#如何解决"><span>如何解决</span></a></h2><p>主要解决办法就是尽量避免生成相同的 bundle，可以通过以下方法：</p><h3 id="使用更复杂的哈希算法" tabindex="-1"><a class="header-anchor" href="#使用更复杂的哈希算法"><span>使用更复杂的哈希算法</span></a></h3><p>可以指定 webpack 使用更复杂的哈希算法：例如 SHA-256、SHA-512 等。这些算法的哈希值复杂度更高、长度更长、碰撞的概率也更低。</p><h3 id="修改哈希算法的生成策略" tabindex="-1"><a class="header-anchor" href="#修改哈希算法的生成策略"><span>修改哈希算法的生成策略</span></a></h3><ol><li><code>contenthash</code>：根据文件内容计算的哈希值，所以文件内容不同，<code>contenthash</code> 也不同，不会产生哈希碰撞。</li><li><code>chunkhash</code>：根据文件内容计算的哈希值，但是它是根据文件所属的代码块（chunk）来计算的，所以如果文件所属的代码块内容不同，<code>chunkhash</code> 也不同，不会产生哈希碰撞。</li></ol><h3 id="修改哈希值长度" tabindex="-1"><a class="header-anchor" href="#修改哈希值长度"><span>修改哈希值长度</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 根据文件体积自动调整哈希位数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">output</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  filename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">[name].[contenthash:auto].js</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 体积&gt;1MB → 16位</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  assetModuleFilename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">[name].[hash:12][ext]</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 12 位 Hash</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="人工加盐" tabindex="-1"><a class="header-anchor" href="#人工加盐"><span>人工加盐</span></a></h3><p>在 bundle 的文件名中加入一些变化的字符串，如 <mark>文件的 size</mark>、<mark>时间戳</mark>，这样即使文件内容完全相同，哈希值也会不同，从而避免哈希碰撞。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 采用 12 位哈希 + 时间戳双校验</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">filename</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> \`</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">[name].[contenthash:12].</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">\${</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Date</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">now</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">}</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">.[ext]</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用-plugin-插件检测" tabindex="-1"><a class="header-anchor" href="#使用-plugin-插件检测"><span>使用 plugin 插件检测</span></a></h3><p>可以通过插件来获取并临时保存构建过程中产生的 bundle 信息，在构建过程中随时比对，发现有重复的 bundle 就报错，或者重新生成一个新的 bundle 名称。</p>`,29)])])}const d=i(h,[["render",l]]),p=JSON.parse('{"path":"/notes/Webpack/0aislcs5/","title":"6. 什么是哈希碰撞 | Webpack","lang":"zh-CN","frontmatter":{"title":"6. 什么是哈希碰撞","createTime":"2025/06/20 22:50:47","permalink":"/notes/Webpack/0aislcs5/"},"readingTime":{"minutes":2.9,"words":871},"git":{"createdTime":1750437350000,"updatedTime":1764524144000,"contributors":[{"name":"kangkang shang","username":"","email":"535634238@qq.com","commits":5,"avatar":"https://gravatar.com/avatar/899a2a8091fc73ff6879f8a45f98a5a42ca8b9665bca19ce8af3a144e416ed11?d=retro"}],"changelog":[{"hash":"37a5215b25a66c978fe447e5ce9d1d1acc9adaad","time":1764524144000,"email":"535634238@qq.com","author":"kangkang shang","message":"docs: 更新文档结构和内容"},{"hash":"72816deec6854f0fe52a07b66232327bac39df0f","time":1750507679000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"adc2eb3232be62c771cf4a707d8243dd51d6fbd7","time":1750438597000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"a301a448d71547d790dc227ad0c2c62112f0824f","time":1750438073000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"},{"hash":"56b5431cfe4c4c14d1fe245002d61284c19886a0","time":1750437350000,"email":"535634238@qq.com","author":"kangkang shang","message":"1"}]},"filePathRelative":"notes/Webpack/99.面试题/6. 什么是哈希碰撞.md","headers":[],"bulletin":false}');export{d as comp,p as data};
