import{_ as i,c,d as o,b as d,w as t,r,o as s,a as e,e as l}from"./app-Bg7EXfK3.js";const u={};function p(h,n){const a=r("VPCard");return s(),c("div",null,[n[2]||(n[2]=o('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>在 CSS 中，元素的某些属性的变化会触发浏览器的 <strong>重绘（Repaint）</strong> 或 <strong>重排（Reflow，也称为重渲染或回流）</strong>。了解这些差异可以帮助开发同学优化页面性能，避免不必要的性能开销。</p><p><strong>重绘：</strong> 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><p><strong>重排：</strong> 当 DOM 的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p><strong>提示：重绘不一定导致重排，但重排一定会导致重绘。</strong></p><h2 id="什么情况下会触发重绘" tabindex="-1"><a class="header-anchor" href="#什么情况下会触发重绘"><span>什么情况下会触发重绘</span></a></h2><p>触发回流时一定会触发重绘，除此以外，例如颜色修改，设置圆角、文本方向修改，阴影修改等。</p><p>重绘的主要特征是：<strong>元素尺寸、位置不变</strong></p>',8)),d(a,null,{default:t(()=>[...n[0]||(n[0]=[e("p",null,"引起重绘的属性，主要包含: 元素的颜色、背景、阴影等发生变化",-1),e("p",null,[e("code",null,"color"),l("、"),e("code",null,"border-style"),l("、"),e("code",null,"visibility"),l("、"),e("code",null,"background"),l("、"),e("code",null,"outline-width"),l("、"),e("code",null,"background-position"),l("、"),e("code",null,"background-repeat"),l("、"),e("code",null,"outline-color"),l("、"),e("code",null,"background-image"),l("、"),e("code",null,"outline-style"),l("、"),e("code",null,"border-radius"),l("、"),e("code",null,"box-shadow"),l("、"),e("code",null,"background-size"),l("、"),e("code",null,"outline"),l("、"),e("code",null,"text-decoration"),l("、"),e("code",null,"line-height"),l("、"),e("code",null,"letter-spacing"),l("、"),e("code",null,"word-spacing"),l("、"),e("code",null,"white-space"),l("、"),e("code",null,"text-transform"),l("、"),e("code",null,"font-size"),l("、"),e("code",null,"font-family"),l("、"),e("code",null,"font-weight")],-1)])]),_:1}),n[3]||(n[3]=o('<h2 id="什么情况下会触发回流" tabindex="-1"><a class="header-anchor" href="#什么情况下会触发回流"><span>什么情况下会触发回流</span></a></h2><p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p><ol><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li><li>页面一开始渲染的时候（这避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ol><h2 id="引起回流的属性" tabindex="-1"><a class="header-anchor" href="#引起回流的属性"><span>引起回流的属性</span></a></h2><p>主要是元素的<code>尺寸和位置发生变化</code>，主要包含：</p><ol><li>可以设置元素<code>尺寸、位置</code>的<code>CSS 属性</code></li><li>内容发生变化，如<code>图片或者文本内容</code>，<code>可以引起元素的位置、尺寸变化</code>。</li></ol>',6)),d(a,null,{default:t(()=>[...n[1]||(n[1]=[e("p",null,[e("code",null,"width"),l("、"),e("code",null,"height"),l("、"),e("code",null,"margin"),l("、"),e("code",null,"padding"),l("、"),e("code",null,"display"),l("、"),e("code",null,"border-width"),l("、"),e("code",null,"border"),l("、"),e("code",null,"position"),l("、"),e("code",null,"overflow"),l("、"),e("code",null,"font-size"),l("、"),e("code",null,"vertical-align"),l("、"),e("code",null,"min-height"),l("、"),e("code",null,"clientWidth"),l("、"),e("code",null,"clientHeight"),l("、"),e("code",null,"clientTop"),l("、"),e("code",null,"clientLeft"),l("、"),e("code",null,"scrollWidth"),l("、"),e("code",null,"scrollHeight"),l("、"),e("code",null,"scrollTop"),l("、"),e("code",null,"scrollLeft"),l("、"),e("code",null,"getComputedStyle()"),l("、"),e("code",null,"getBoundingClientRect()"),l("、"),e("code",null,"scrollIntoViewIfNeeded()"),l("、"),e("code",null,"伪类：如：hover")],-1)])]),_:1}),n[4]||(n[4]=o('<h2 id="减少重排-回流-的优化方式" tabindex="-1"><a class="header-anchor" href="#减少重排-回流-的优化方式"><span>减少重排（回流）的优化方式</span></a></h2><h3 id="控制范围" tabindex="-1"><a class="header-anchor" href="#控制范围"><span>控制范围</span></a></h3><ul><li>精准到节点：操作 DOM 节点的时候，尽量控制范围，精确到某个节点，尽量不要去改动包裹他的父层。</li><li>table、 flex 布局：元素在变化的时候，尽量不要影响整个布局。</li></ul><h3 id="减少次数" tabindex="-1"><a class="header-anchor" href="#减少次数"><span>减少次数</span></a></h3><ul><li>合并操作：不影响逻辑的情况下，尽量把获取和操作 DOM 节点的代码分组，集中操作，典型的就是连续设置、修改多个 Style 属性，可以使用 <code>class</code> 替换。</li><li>读写分离：对 DOM 节点的读写尽量不要混编，即读中夹写，写中夹读。这样会更容易触发回流。</li><li>设置 <code>display: none</code>：将元素的 display 属性设置为 none，修改完全部的样式修改以后，再重新设置显示。这样对主体页面回流的影响只有两次。类似的操作，还可以将元素在 DOM 上删除，然后修改完成后，重新挂载上去。</li><li>脱离文档流：absolute 或 fixed 可以将元素脱离文档流，重排开销小，不会对其他部分产生影响。</li></ul><div class="hint-container tip"><p class="hint-container-title">为什么建议读写分离，批量读、批量写</p><p>浏览器通常会批量处理样式更改，然后统一计算布局和绘制。但当读取布局属性时，浏览器必须立即计算当前布局以确保返回准确值。<br> 因此，读写操作不分离的话，浏览器就需要在每次先写后读的操作之间强制刷新，影响代码性能。</p></div>',6))])}const f=i(u,[["render",p]]),b=JSON.parse('{"path":"/WebBasic/qwgxy36w/","title":"重绘和重排（回流）","lang":"zh-CN","frontmatter":{"title":"重绘和重排（回流）","createTime":"2025/03/15 13:21:27","permalink":"/WebBasic/qwgxy36w/"},"readingTime":{"minutes":3.42,"words":1027},"git":{"createdTime":1758993364000,"updatedTime":1758993364000,"contributors":[{"name":"kangkang shang","username":"","email":"535634238@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/899a2a8091fc73ff6879f8a45f98a5a42ca8b9665bca19ce8af3a144e416ed11?d=retro"}],"changelog":[{"hash":"1eb9b32660588040229600108dbdda4327afcdb3","time":1758993364000,"email":"535634238@qq.com","author":"kangkang shang","message":"docs(Javascript): 更新Generator生成器函数文档内容"}]},"filePathRelative":"notes/WebBasic/1.Web 基础/1.重绘和重排（回流）.md","headers":[],"bulletin":false}');export{f as comp,b as data};
