import{_ as a,c as e,d as i,o as n}from"./app-Bg7EXfK3.js";const t={};function r(h,s){return n(),e("div",null,[...s[0]||(s[0]=[i('<div class="hint-container tip"><p class="hint-container-title">要优化 Webpack 构建的应用程序性能，可以采取以下措施：</p><ul><li>调整代码拆分和 sourceMap 的颗粒度，控制生成文件数量和体积，提高加载速度；</li><li>代码中按需引入、魔法注释标记无副作用的模块来配合 Tree sharking，优化输出。</li><li>调整文件指纹的 hash 复杂度，提高缓存命中率，同事防止哈希碰撞；</li><li>提取公共模块，第三方依赖、runtime 文件；</li><li>js、css 的兼容性处理</li><li>压缩代码、图片、视频 ，必要时利用 CDN；</li><li>prefetch、preload、preconnect 技术</li></ul></div><h2 id="一、webpack-的配置优化" tabindex="-1"><a class="header-anchor" href="#一、webpack-的配置优化"><span>一、webpack 的配置优化</span></a></h2><h3 id="_1、开启生产模式" tabindex="-1"><a class="header-anchor" href="#_1、开启生产模式"><span>1、开启生产模式</span></a></h3><p>在生产模式下，Webpack 会自动启用一些优化选项，例如：</p><ul><li>缓存</li><li>Tree Shaking</li><li>html 代码压缩</li><li>js 代码压缩</li></ul><h3 id="_2、代码拆分-提取公共代码" tabindex="-1"><a class="header-anchor" href="#_2、代码拆分-提取公共代码"><span>2、代码拆分，提取公共代码</span></a></h3><p>设置代码拆分策略时，不需要关注并行加载数量、最大体积、最小体积这种配置项，保持默认就行，只配置 <code>chunks: &quot;all&quot;</code> 即可。</p><p>我们需要关注的是 <code>cacheGroup</code> 配置项目，主要就是为了把公共的、不常变化的代码打包到一起。</p><ul><li>公共代码：主要指 <code>common</code>、<code>util</code>、<code>layout</code>。</li><li>Runtime 文件：和公共代码类似，runtime 代码是 webpack 用来处理模块依赖的辅助代码、胶水代码。</li><li>第三方依赖（Vendor）：其实就是把 <code>node_module</code> 拆分成多个 Vendor，把诸如 Element-UI、Vue、Loadash 等体积较大的包拆分出来单独打包。</li><li>魔法注释：Webpack 提供魔法注释 <code>/* webpackChunkName: &quot;name&quot; */</code>，我们可以用来标记 <code>import()</code> 引入的模块，这样可以给代码拆分后的文件起一个自定义的名称，一般用来标记路由组件、公共组件、第三方库等。</li></ul><h3 id="_3、调整文件指纹-提高缓存利用率" tabindex="-1"><a class="header-anchor" href="#_3、调整文件指纹-提高缓存利用率"><span>3、调整文件指纹，提高缓存利用率</span></a></h3><p>在 <strong>避免哈希碰撞</strong> 的情况下，对生成的文件采用<strong>更复杂</strong> 的哈希值生成策略，如 <code>contenthash</code>、<code>chunkhash</code> 等，这样可以有效降低打包的影响范围，从而提高浏览器缓存的利用率，提高缓存的命中率。</p><h3 id="_4、js-和-css-的兼容性处理" tabindex="-1"><a class="header-anchor" href="#_4、js-和-css-的兼容性处理"><span>4、JS 和 CSS 的兼容性处理</span></a></h3><ul><li>JS：使用 <code>babel</code> 和 <code>core-js</code> 去处理 js 的兼容性</li><li>CSS：使用 <code>postCss</code> 去处理 <code>CSS</code> 的兼容性，</li></ul><h3 id="_5、使用预加载技术优化懒加载" tabindex="-1"><a class="header-anchor" href="#_5、使用预加载技术优化懒加载"><span>5、使用预加载技术优化懒加载</span></a></h3><p>我们可以使用<code>preload</code> 和 <code>prefetch</code> 功能来提前加载和推迟加载资源。</p><p>Webpack 支持在 <code>import()</code> 中使用魔法注释，来标记需要预加载的资源。一般，我们可以在路由、公共组件、或者用户交互的位置，标记需要预加载的资源。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">import</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">/* webpackPreload: true */</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">./moduleA</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_6、代码压缩、转化" tabindex="-1"><a class="header-anchor" href="#_6、代码压缩、转化"><span>6、代码压缩、转化</span></a></h3><ul><li><strong>Html、Js：</strong> <code>webpack5</code>会对<code>html</code>和<code>js</code>默认压缩</li><li><strong>CSS：</strong> 可以配置压缩，也可以使用<code>MiniCssExtractPlugin</code> 插件单独提取成单独的样式文件。</li><li><strong>视频：</strong> 视频压缩；上传 CDN、静态资源服务器</li><li><strong>图片：</strong> 图片压缩；转化为 dataUrl 格式；雪碧图（多张小图片合并成大图）；使用字体图标库代替；上传 CDN、静态资源服务器。</li></ul><h3 id="_7、关闭或降低-sourcemap-的生成精度" tabindex="-1"><a class="header-anchor" href="#_7、关闭或降低-sourcemap-的生成精度"><span>7、关闭或降低 sourceMap 的生成精度</span></a></h3><p>非必要情况下，可以 <strong>关闭</strong>，甚至 <strong>降低</strong> sourceMap 生成 map 文件的<strong>精细度</strong> ，可以非常有效的降低代码生成体积，提高加载速度。</p><h3 id="_8、使用-pwa-技术-处理某些极端情况" tabindex="-1"><a class="header-anchor" href="#_8、使用-pwa-技术-处理某些极端情况"><span>8、使用 PWA 技术，处理某些极端情况</span></a></h3><p>渐进式网络应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程序) 体验的 Web App 的技术。</p><p>其中最重要的是，在用户 <strong>突然离线</strong> 时，应用程序能够 <strong>继续运行</strong> 功能。通过 Service Workers 技术实现的。</p><h2 id="二、代码中的优化" tabindex="-1"><a class="header-anchor" href="#二、代码中的优化"><span>二、代码中的优化</span></a></h2><h3 id="_1、按需引入模块" tabindex="-1"><a class="header-anchor" href="#_1、按需引入模块"><span>1、按需引入模块</span></a></h3><p>引入公共组件时，按需引入需要的部分，这样 webpack 会在打包带时候将未引入的部分剔除</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> funA</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">./Module</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2、降低文件的副作用" tabindex="-1"><a class="header-anchor" href="#_2、降低文件的副作用"><span>2、降低文件的副作用</span></a></h3><p>封装组件的时候，尽量降低文件的副作用，配合<code>/*#__PURE__*/</code>标记函数，配合 Tree Shaking 无副作用移除代码</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> result</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /*#__PURE__*/</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> someFunction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2、路由或组件的按需加载-即懒加载" tabindex="-1"><a class="header-anchor" href="#_2、路由或组件的按需加载-即懒加载"><span>2、路由或组件的按需加载，即懒加载</span></a></h3><p>路由或组件的懒加载可以配合缓存和代码拆分</p><ul><li>路由、复杂组件的懒加载：路由的按需加载（使用 es 模块化的异步加载 <code>import()</code>）配合 <strong>webpack 魔法名称</strong>，提示 webpack 拆分</li></ul><h3 id="_3、图片、视频的压缩、转化" tabindex="-1"><a class="header-anchor" href="#_3、图片、视频的压缩、转化"><span>3、图片、视频的压缩、转化</span></a></h3><ul><li><p><strong>雪碧图：</strong> 样式有关的小尺寸图片，比如图标， <strong>合并成一张大图片</strong> ，在 css 中用偏移量去控制。这样可以利用浏览器缓存来减少 http 请求数量。</p></li><li><p><strong>静态资源服务器、CDN：</strong> 可以考虑使用静态资源服务器或 CDN 服务器，将大体积的图片和视频上传，在代码中使用 <strong>URL 地址</strong> 去引入资源。</p></li></ul><h3 id="_4、cdn-加速" tabindex="-1"><a class="header-anchor" href="#_4、cdn-加速"><span>4、CDN 加速</span></a></h3><p>以下资源可以使用 CDN 加速，来提高加载速度，但是要<strong>控制数量</strong>，<strong>避免大幅度增加 Http 请求数量</strong></p><ul><li><strong>第三方库：</strong> 如 jQuery，bootstrap 之类的第三方库，</li><li><strong>特殊的字体文件：</strong> 如某些版权字体、font-awsome。</li><li><strong>大尺寸图片或视频</strong></li></ul><h3 id="_5、preconnect" tabindex="-1"><a class="header-anchor" href="#_5、preconnect"><span>5、preconnect</span></a></h3><h3 id="_6、谷歌浏览器的-hsts" tabindex="-1"><a class="header-anchor" href="#_6、谷歌浏览器的-hsts"><span>6、谷歌浏览器的 HSTS</span></a></h3>',41)])])}const d=a(t,[["render",r]]),o=JSON.parse('{"path":"/Webpack/14ef8fox/","title":"5. 如何优化生产环境的运行性能？","lang":"zh-CN","frontmatter":{"title":"5. 如何优化生产环境的运行性能？","createTime":"2025/03/15 14:24:59","permalink":"/Webpack/14ef8fox/"},"readingTime":{"minutes":4.4,"words":1321},"git":{"createdTime":1758993364000,"updatedTime":1758993364000,"contributors":[{"name":"kangkang shang","username":"","email":"535634238@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/899a2a8091fc73ff6879f8a45f98a5a42ca8b9665bca19ce8af3a144e416ed11?d=retro"}],"changelog":[{"hash":"1eb9b32660588040229600108dbdda4327afcdb3","time":1758993364000,"email":"535634238@qq.com","author":"kangkang shang","message":"docs(Javascript): 更新Generator生成器函数文档内容"}]},"filePathRelative":"notes/Webpack/99.面试题/5.如何优化生产环境的运行性能？.md","headers":[],"bulletin":false}');export{d as comp,o as data};
