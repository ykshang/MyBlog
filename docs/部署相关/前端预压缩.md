---
title: 前端预压缩
createTime: 2025/06/29 00:31:29
permalink: /article/iir8otql/
---

## 前端预压缩

Webpack 配置 Gzip 压缩的方案，属于**前端预压缩**。这种在构建阶段生成 `.gz` 文件的方式，与服务器实时压缩有本质区别。

### 预压缩的三大特征

#### 1、构建阶段完成压缩

在 `npm run build` 时生成 `.gz` 文件，而非用户请求时压缩

#### 2、产物包含压缩文件

输出目录中同时存在压缩文件和原始文件，例如 `main.js` 和 `main.js.gz`

```bash
dist/
├─ main.js
├─ main.js.gz  # 预压缩生成
├─ style.css
├─ style.css.gz
```

#### 3、服务器直接使用

Nginx 等服务器只需配置`gzip_static on`即可直接发送预压缩文件

```nginx
# Nginx配置
gzip_static on;  # 关键指令
gunzip on;       # 兼容不支持gzip的客户端
gzip off;        # 禁用动态压缩
```

### 与实时压缩的对比

传统的实时压缩方案，需要在服务器上配置 Gzip 模块，且每个请求都需要实时压缩。这样的操作比较考验服务器的配置和性能，而 Webpack 预压缩方案，在构建阶段一次性完成压缩，服务器无需额外配置，直接返回对应的 `.gz` 文件。

| 特性     | 预压缩                   | 服务器实时压缩           |
| -------- | ------------------------ | ------------------------ |
| 压缩时机 | 构建阶段                 | 请求时实时压缩           |
| CPU 消耗 | 构建时一次性消耗         | 每次请求消耗 CPU         |
| 响应速度 | 极快（直接发送静态文件） | 较慢（需要实时压缩）     |
| 适用场景 | 静态资源                 | 动态 API 响应            |
| 部署要求 | 需上传.gz 文件           | 只需服务器启用 gzip 模块 |

## 压缩算法的选择

### Gzip 压缩

Gzip 是一种广泛使用的压缩算法，被广泛用于 HTTP 协议中。它通过对文件内容进行 **无损压缩**，并使用 **LZ77** + **哈夫曼编码** 来实现。

#### 压缩流程

1. LZ77 压缩阶段：

   - 使用 LZ77 算法在文件中查找重复出现的字符串，并使用短代码 `<距离,长度>` 替换。
   - 例如：`"abc123abc456"` → `"abc123<6,3>456"`（`<6,3>`表示向前 6 个字符开始复制 3 个字符）

2. 哈夫曼编码阶段：

   - 统计字符频率：根据文件中每个字符出现的频率，构建一个哈夫曼树。
   - 动态编码：使用哈夫曼编码对字符进行编码，确保出现频率高的字符使用较短的编码，频率低的字符使用较长的编码。
   - 例如：`{'a': '0', 'b': '10', 'c': '110'}`

3. 封装输出

   - 添加文件头（含元信息）：压缩标识、压缩级别、操作系统标识、时间戳和额外标志位等
   - 添加 CRC 校验码
   - 生成 `.gz` 后缀的压缩文件

#### 解压缩流程

解压缩流程就是压缩流程的逆过程

- 读取头部：读取 `.gz` 文件的头部信息，确认压缩参数和校验码。
- 哈夫曼解码：根据头部信息中的哈夫曼编码表，对文件内容进行解码。
- LZ77 还原：根据 LZ77 算法的规则，将解码后的内容还原为原始数据。

### Brotli 压缩

Brotli 是 Google 开发的一种新的压缩算法，它在压缩效率和压缩速度之间取得了平衡。与 Gzip 相比，Brotli 提供更高的压缩率，但压缩速度较慢。

### 压缩算法的对比

## 实现方案

### Webpack 实现预压缩

Webpack 主要通过 `compression-webpack-plugin` 来实现与压缩文件的生成

## 四、正确配置要点

1. **插件配置示例**：

   ```javascript
   // webpack.config.js
   const CompressionPlugin = require("compression-webpack-plugin");

   module.exports = {
     plugins: [
       new CompressionPlugin({
         filename: "[path][base].gz",
         algorithm: "gzip",
         test: /\.(js|css|html|json)$/,
         threshold: 10240, // 10KB以上才压缩
         minRatio: 0.8, // 压缩率>80%才生成
       }),
     ],
   };
   ```

2. **必须配合的服务器配置**：
   ```nginx
   # Nginx配置
   gzip_static on;  # 关键指令
   gunzip on;       # 兼容不支持gzip的客户端
   gzip off;        # 禁用动态压缩
   ```

## 五、验证预压缩是否生效

1. **检查构建产物**：

   ```bash
   ls -lh dist/
   # 应看到类似：
   # -rw-r--r--  1 user  staff    50K Aug  1 10:00 main.js.gz
   ```

2. **网络请求验证**：
   ```bash
   curl -H "Accept-Encoding: gzip" -I https://yoursite.com/main.js
   ```
   响应头应包含：
   ```
   Content-Encoding: gzip
   X-Content-Encoding-Over-Network: gzip
   ```

## 六、与其他方案的对比

| 方案            | 预压缩性质 | 优点             | 缺点                 |
| --------------- | ---------- | ---------------- | -------------------- |
| Webpack 生成.gz | ✅ 是      | 构建时一次完成   | 需配置服务器支持     |
| 服务器实时压缩  | ❌ 否      | 无需前端特殊处理 | 每次请求消耗 CPU     |
| CDN 边缘压缩    | ⚠️ 部分    | 减轻源站压力     | 首次请求仍有压缩延迟 |

## 七、最佳实践建议

1. **只对生产环境启用**：

   ```javascript
   plugins: [
     process.env.NODE_ENV === "production" &&
       new CompressionPlugin({
         /* 配置 */
       }),
   ].filter(Boolean);
   ```

2. **配合 Brotli 预压缩**（更现代算法）：

   ```javascript
   new CompressionPlugin({
     filename: "[path][base].br",
     algorithm: "brotliCompress",
     test: /\.(js|css|html)$/,
     compressionOptions: { level: 11 },
   });
   ```

3. **监控文件大小**：
   ```bash
   # 检查压缩效果
   find dist -name "*.gz" -exec du -h {} +
   ```

Webpack 的 Gzip 压缩是典型的前端预压缩方案，能有效提升性能，但必须配合正确的服务器配置才能发挥最大价值。

## Webpack 配置 Gzip 压缩

### 安装 compression-webpack-plugin 插件

```bash
npm install compression-webpack-plugin@^9.0.0 --save-dev
```

### 完整 webpack 配置示例

```javascript
const CompressionPlugin = require("compression-webpack-plugin");

module.exports = {
  plugins: [
    new CompressionPlugin({
      filename: "[path][base].gz", // 输出文件名模式
      algorithm: "gzip", // 使用gzip算法
      test: /\.(js|css|html|json|svg|txt|eot|otf|ttf|woff|woff2)$/, // 压缩文件类型
      threshold: 10240, // 只压缩大于10KB的文件
      minRatio: 0.8, // 只有压缩率优于80%才会压缩
      deleteOriginalAssets: false, // 保留原始文件
      cache: true, // 启用缓存
      compressionOptions: {
        level: 9, // 最高压缩级别
      },
    }),
  ],
};
```

### 构建参数说明

| 参数                   | 类型            | 默认值            | 说明                                         |
| ---------------------- | --------------- | ----------------- | -------------------------------------------- |
| `filename`             | String/Function | `[path][base].gz` | 生成的压缩文件名模式                         |
| `algorithm`            | String/Function | `gzip`            | 压缩算法，支持 `gzip`/`deflate`/`deflateRaw` |
| `test`                 | RegExp/Array    | 匹配所有文件      | 指定需要压缩的文件类型                       |
| `threshold`            | Number          | `0`               | 文件大小阈值（字节），大于此值才压缩         |
| `minRatio`             | Number          | `0.8`             | 压缩比阈值，小于此值才压缩                   |
| `deleteOriginalAssets` | Boolean         | `false`           | 是否删除原始文件                             |
| `cache`                | Boolean/String  | `false`           | 启用缓存或指定缓存目录                       |
| `compressionOptions`   | Object          | `{}`              | 传递给 zlib 的选项                           |

## Node.js 服务器配置

### Express 服务器详细配置

```javascript
const express = require("express");
const compression = require("compression");
const zlib = require("zlib");

const app = express();

// 高级压缩配置
app.use(
  compression({
    level: zlib.constants.Z_BEST_COMPRESSION, // 压缩级别
    memLevel: 9, // 内存使用级别(1-9)
    strategy: zlib.constants.Z_DEFAULT_STRATEGY, // 压缩策略
    threshold: "10kb", // 最小压缩大小
    filter: (req, res) => {
      // 自定义过滤规则
      const type = res.getHeader("Content-Type") || "";
      const shouldCompress = /text|javascript|json|xml|font|svg/.test(type);

      if (req.headers["x-no-compression"]) {
        return false;
      }
      return shouldCompress;
    },
  })
);

// 静态文件服务（优先使用预压缩文件）
app.get("*.js", (req, res, next) => {
  if (req.acceptsEncodings("gzip")) {
    req.url = req.url + ".gz";
    res.set("Content-Encoding", "gzip");
    res.set("Content-Type", "application/javascript");
    res.set("Vary", "Accept-Encoding");
  }
  next();
});

app.use(express.static("dist"));

app.listen(3000, () => {
  console.log("Server running with Gzip compression");
});
```

### 压缩中间件参数详解

| 参数        | 类型          | 默认值                       | 说明                              |
| ----------- | ------------- | ---------------------------- | --------------------------------- |
| `level`     | Integer       | `-1` (Z_DEFAULT_COMPRESSION) | 压缩级别(0-9)                     |
| `memLevel`  | Integer       | `8`                          | 内存使用级别(1-9)                 |
| `strategy`  | Integer       | `0` (Z_DEFAULT_STRATEGY)     | 压缩策略                          |
| `threshold` | Number/String | `0`                          | 最小压缩大小(字节或字符串如'1kb') |
| `filter`    | Function      | 默认过滤文本类型             | 自定义压缩过滤函数                |

## Nginx 服务器详细配置

### 完整 Nginx Gzip 配置

```nginx
http {
  # 基本Gzip配置
  gzip on;
  gzip_http_version 1.1;
  gzip_comp_level 6;
  gzip_min_length 1024;
  gzip_proxied any;
  gzip_vary on;

  # 压缩类型配置
  gzip_types
    text/plain
    text/css
    text/javascript
    text/xml
    application/javascript
    application/x-javascript
    application/json
    application/xml
    application/xml+rss
    application/vnd.ms-fontobject
    application/x-font-ttf
    font/opentype
    image/svg+xml;

  # 预压缩文件配置
  gzip_static on;
  gunzip on;

  # 禁用特定浏览器的Gzip
  gzip_disable "MSIE [1-6]\.";

  # 其他优化参数
  gzip_buffers 16 8k;
}
```

### Nginx 配置参数详解

| 指令                | 值类型        | 默认值      | 说明                                    |
| ------------------- | ------------- | ----------- | --------------------------------------- |
| `gzip`              | on/off        | off         | 启用/禁用 Gzip 压缩                     |
| `gzip_http_version` | 1.0/1.1       | 1.1         | 最小 HTTP 版本要求                      |
| `gzip_comp_level`   | 1-9           | 1           | 压缩级别(越高压缩率越大但 CPU 消耗越高) |
| `gzip_min_length`   | 字节数        | 20          | 最小压缩文件大小                        |
| `gzip_proxied`      | 多种选项      | off         | 对代理请求的压缩行为                    |
| `gzip_vary`         | on/off        | off         | 是否添加"Vary: Accept-Encoding"头       |
| `gzip_types`        | MIME 类型列表 | text/html   | 指定压缩的文件类型                      |
| `gzip_static`       | on/off/always | off         | 优先使用预压缩文件(.gz)                 |
| `gunzip`            | on/off        | off         | 为不支持 Gzip 的客户端解压              |
| `gzip_buffers`      | number size   | 32 4k/16 8k | 压缩缓冲区数量和大小                    |

### 推荐的 Nginx 压缩类型

```nginx
gzip_types
  text/plain
  text/css
  text/javascript
  text/xml
  text/x-component
  application/javascript
  application/x-javascript
  application/json
  application/xml
  application/xml+rss
  application/xhtml+xml
  application/rss+xml
  application/atom+xml
  application/vnd.ms-fontobject
  application/x-font-ttf
  application/x-font-opentype
  application/x-font-truetype
  font/eot
  font/opentype
  font/otf
  image/svg+xml
  image/x-icon;
```

## 验证 Gzip 是否生效

### 使用 curl 命令验证

```bash
curl -H "Accept-Encoding: gzip" -I http://yourserver.com/main.js

# 预期输出应包含：
# Content-Encoding: gzip
# Vary: Accept-Encoding
```

### 浏览器开发者工具检查

1. 打开 Chrome 开发者工具(F12)
2. 切换到 Network 标签
3. 刷新页面
4. 点击任意资源文件，查看响应头：
   - 应有`content-encoding: gzip`
   - 比较`Content-Length`和资源实际大小

### 文件大小对比检查

```bash
# 原始文件大小
ls -lh dist/main.js

# Gzip压缩后大小
ls -lh dist/main.js.gz
```

## 性能优化建议

1. **静态文件**：

   - 使用 Webpack 预生成.gz 文件
   - 配置 Nginx 优先使用预压缩文件(`gzip_static on`)

2. **动态内容**：

   - 使用 Node.js 中间件实时压缩
   - 设置适当的压缩级别(通常 6 是最佳平衡点)

3. **缓存配置**：

   ```nginx
   location ~* \.(js|css|html|json)$ {
     expires 1y;
     add_header Cache-Control "public, immutable";
     add_header Vary "Accept-Encoding";
   }
   ```

4. **监控与调优**：
   - 监控服务器 CPU 使用率
   - 根据实际流量调整`gzip_comp_level`
   - 定期检查压缩率是否正常
