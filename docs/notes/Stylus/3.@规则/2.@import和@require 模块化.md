---
title: "@import 和 @require 模块化"
createTime: 2025/04/22 19:24:43
permalink: /Stylus/kci6qv0w/
---

Stylus 既支持 CSS 原生的 `@import` 语法，也支持动态导入或引入其他 Stylus 样式表。

## 一、简介

免责声明：在所有使用 `@import` 导入 Stylus 样式表的场景中，都可以用 `@require` 替代

### 1、文件类型可以缺省

当使用 `@import` 且未指定 `.css` 扩展名时，Stylus 会默认将其视为 Stylus 样式表（例如 `@import "mixins/border-radius"`）。

### 2、文件路径查找规则

`@import` 的工作机制是通过遍历目录数组，检查目标文件是否存在于这些目录中（类似于 Node.js 的 `require.paths`）。该数组默认包含单个路径，该路径派生自 `filename` 选项的目录名。例如，如果当前文件名是 `/tmp/testing/stylus/main.styl`，则导入操作将在 `/tmp/testing/stylus/` 目录下查找。

### 3、索引文件模式查找

`@import` 支持索引文件模式。

例如：代码中有这样一个导入 `@import blueprint` 代码，Stylus 会解析为 `blueprint.styl` 或 `blueprint/index.styl`。

这个特性对于需要暴露全部功能同时允许按需导入子模块的库非常有用。

以下是一个典型的库目录结构示例：

::: file-tree

- tablet
  - index.styl
  - vendor.styl
  - buttons.styl
  - images.styl

:::

在下面的示例中，我们通过设置 `paths` 选项为 Stylus 提供额外路径。在 `./test.styl` 文件中，既可以 `@import "mixins/border-radius"`，也可以直接 `@import "border-radius"`（因为 `./mixins` 目录已对 Stylus 暴露）。

```js
/**
 * Module dependencies.
 */

var stylus = require("../");
var str = require("fs").readFileSync(__dirname + "/test.styl", "utf8");

var paths = [__dirname, __dirname + "/mixins"];

stylus(str)
  .set("filename", __dirname + "/test.styl")
  .set("paths", paths)
  .render(function (err, css) {
    if (err) throw err;
    console.log(css);
  });
```

### 4、导入 CSS 文件

任何以 `.css` 为扩展名的文件都将被视为 CSS 字面量。例如：

```styl
 @import "reset.css"
```

会渲染出如下所示的 CSS 原生 `@import` 语句：

```
 @import "reset.css"
```

## 二、其他特性

### 1、块级导入

Stylus 支持块级导入，这意味着 `@import` 不仅可以在根层级使用，还能嵌套在其他选择器或其他 `@rule` 内部。

假设你有一个 `bar.styl` 文件，代码如下：

```styl
.bar
  width: 10px;
```

我们可以在 `foo.styl` 文件中导入 `bar.styl`，代码如下：

```styl
.foo
  @import 'bar.styl'

@media screen and (min-width: 640px)
  @import 'bar.styl'
```

然后你得到的编译结果为：

```css
.foo .bar {
  width: 10px;
}
@media screen and (min-width: 640px) {
  .bar {
    width: 10px;
  }
}
```

### 2、使用文件通配符导入

Stylus 支持文件通配符[(globbing)](https://github.com/isaacs/node-glob#readme)功能，通过该功能可以使用文件通配符一次性导入多个文件：

```styl
@import 'product/*'
```

该指令将会导入 `product` 目录下的所有 Stylus 样式表，其目录结构如下所示：

::: file-tree

- product
  - body.styl
  - foot.styl
  - head.styl

:::

请注意该功能同样适用于 `@require`，当存在 `./product/index.styl` 文件且包含以下内容时：

```
@require 'head'
@require 'body'
@require 'foot'
```

此时 `@require 'product/*'` 将只会包含每个独立样式表仅一次。

### 3、相对路径解析

默认情况下，Stylus 不会自动解析被导入 `.styl` 文件中的相对路径。

例如我们有以下目录结构：
::: file-tree

- foo
  - foo.styl
  - bar - bar.styl - baz.png

:::
其中 `bar.styl` 中包含以下内容：

```styl
div
  background: url("baz.png")
```

我们在 `foo.styl` 中使用相对路径引入`bar/styl`：

```styl
@import "bar/bar.styl"
```

那么编译后的 CSS 中 `url("baz.png")` 不会被解析为 `url("bar/baz.png")`。
如果我们想让 `url("baz.png")` 被解析为 `url("bar/baz.png")`，我们可以使用 `--resolve-url`（或简写 `-r`）CLI 选项：

### 4、JavaScript 中的 `import`

当使用 `.import(path)` 方法时，这些导入操作会延迟到评估 `evaluation` 阶段执行：

```js
var stylus = require("../");
var str = require("fs").readFileSync(__dirname + "/test.styl", "utf8");

stylus(str)
  .set("filename", __dirname + "/test.styl")
  .import("mixins/vendor")
  .render(function (err, css) {
    if (err) throw err;
    console.log(css);
  });
```

以下代码块：

```styl
 @import 'mixins/vendor'
```

等效于：

```js
 .import('mixins/vendor')
```

## 三、`@import` vs `@require`

除 `@import` 外，Stylus 还提供了 `@require` 指令。两者的工作方式基本类似，区别在于 `@require` 对同一文件只会导入一次。
