---
title: 其他实用函数
createTime: 2025/04/18 22:31:52
permalink: /Stylus/qklsdk67/
badge:
  text: "11"
  type: "tip"
---

## 一、`called-from` 输出调用堆栈信息

`called-from` 用于返回当前函数的调用堆栈信息 ‌。具体来说，`called-from` 属性包含以倒序调用当前函数的函数列表，其中第一项是最深的函数。类似于 JavaScript 中的 `console.trace()`。

我们来回顾一下 JavaScript 中的 `console.trace()` 方法：

```js
function outer() {
  middle();
}

function middle() {
  inner();
}

function inner() {
  console.trace(); // 打印调用堆栈
}

outer();
```

```console
console.trace                      VM2111:10
  inner	@	VM2111:10
  middle	@	VM2111:6
  outer	@	VM2111:2
  (anonymous)	@	VM2111:13
```

`called-from` 的使用方法与 `console.trace()` 类似，它返回一个字符串，其中包含以倒序调用当前函数的函数列表。

```styl
foo()
  bar()

bar()
  baz()

baz()
  return called-from

foo() // => bar foo
```

## 二、`current-media()` 输出当前媒体查询信息

`current-media()` 用于返回当前媒体查询信息（`@media()`）。具体来说，`current-media()` 属性包含当前媒体查询的字符串。如果块上方没有 `@media`，则返回 `''`。

```styl
@media only screen and (min-width: 1024px)
  current-media()
// => '@media (only screen and (min-width: (1024px)))'
```

## 三、`+cache(keys...)`

`+cache(keys...)` 是 Stylus 中的一个高级混合(mixin)功能，用于创建带有缓存机制的样式块，可以避免重复生成相同的 CSS 代码。第一次调用的时候，Stylus 会将生成的 CSS 代码缓存起来，后续调用的时候，会使用相同的参数对第一次调用的结果进行`@extend`。

具体来说，`+cache(keys...)` 可以传入多个参数，多个参数组合成一个缓存键，用于标识当前 mixin。如果 `keys` 相同，则返回相同的结果。`keys`的顺序不同会被视为不同的缓存键。

#### 实现原理

Stylus 在编译时会：

- 为每个 +cache 块创建唯一的哈希标识
- 检查是否已有相同哈希的样式输出
- 如果存在则跳过，不存在则生成并记录

#### 示例

```styl
size($width, $height = $width)
  +cache('w' + $width)
    width: $width
  +cache('h' + $height)
    height: $height

.a
  size: 10px 20px
.b
  size: 10px 2em
.c
  size: 1px 2em
```

编译为：

```
.a,
.b {
  width: 10px;
}
.a {
  height: 20px;
}
.b,
.c {
  height: 2em;
}
.c {
  width: 1px;
}
```

### +prefix-classes(prefix)[#](https://stylus.nodejs.cn/docs/bifs.html#prefix-classesprefix)

Stylus 附带了一个块 mixin `prefix-classes`，可用于为任何给定 Stylus 块内的类添加前缀。例如：

```
+prefix-classes('foo-')
  .bar
    width: 10px
```

产量：

```
.foo-bar {
  width: 10px;
}
```

### lookup(name)[#](https://stylus.nodejs.cn/docs/bifs.html#lookupname)

允许查找名为 `name` 的变量的值（以字符串形式传递）。如果变量未定义，则返回 `null`。

当你需要获取具有动态生成名称的变量的值时很有用：

```
font-size-1 = 10px
font-size-2 = 20px
font-size-3 = 30px

for i in 1..3
  .text-{i}
    font-size: lookup('font-size-' + i)
```

产量：

```
.text-1 {
  font-size: 10px;
}
.text-2 {
  font-size: 20px;
}
.text-3 {
  font-size: 30px;
}
```

### define(name, expr[, global])[#](https://stylus.nodejs.cn/docs/bifs.html#definename-expr-global)

允许使用给定的 `name` 创建或覆盖变量，以字符串形式传递到当前作用域（如果 `global` 为 true，则为全局作用域）。

在需要在变量名称中进行插值的情况下，此 BIF 非常有用：

```
prefix = 'border'
border = { color: #000, length: 1px, style: solid }

for prop, val in border
  define(prefix + '-' + prop, val)

body
  border: border-length border-style border-color
```

产量：

```
body {
  border: 1px solid #000;
}
```

### operate(op, left, right)[#](https://stylus.nodejs.cn/docs/bifs.html#operateop-left-right)

对 `left` 和 `right` 操作数执行给定的 `op`：

```
op = '+'
operate(op, 15, 5)
// => 20
```

### selector()[#](https://stylus.nodejs.cn/docs/bifs.html#selector)

返回已编译的当前选择器或 `&`（如果在根级别调用）。

```
.foo
  selector()
// => '.foo'

.foo
  &:hover
    selector()
// '.foo:hover'
```

### selector-exists(selector)[#](https://stylus.nodejs.cn/docs/bifs.html#selector-existsselector)

如果 `selector` 存在则返回 true..

```
.foo
  color red

  a
    font-size 12px

selector-exists('.foo') // true
selector-exists('.foo a') // true
selector-exists('.foo li') // false
selector-exists('.bar') // false
```

此方法不考虑当前上下文含义：

```
.foo
  color red

  a
    font-size 12px

  selector-exists('a') // false
  selector-exists(selector() + ' a') // true
```

### opposite-position(positions)[#](https://stylus.nodejs.cn/docs/bifs.html#opposite-positionpositions)

返回给定 `positions` 的相反数。

```
opposite-position(right)
// => left

opposite-position(top left)
// => bottom right

opposite-position('top' 'left')
// => bottom right
```

### image-size(path)[#](https://stylus.nodejs.cn/docs/bifs.html#image-sizepath)

返回在 `path` 处找到的图片的 `width` 和 `height`。查找的执行方式与 `@import` 相同，但由 `paths` 设置更改。

```
width(img)
  return image-size(img)[0]

height(img)
  return image-size(img)[1]

image-size('tux.png')
// => 405px 250px

image-size('tux.png')[0] == width('tux.png')
// => true
```

### embedurl(path[, encoding])[#](https://stylus.nodejs.cn/docs/bifs.html#embedurlpath-encoding)

以 `url()` 字面量形式返回内嵌图片，并使用 `encoding` 进行编码。

（可用编码：`base64`（默认）和 `utf8`）。

```
background: embedurl('logo.png')
// => background: url("data:image/png;base64,…")

background: embedurl('logo.svg', 'utf8')
// => background: url("data:image/svg+xml;charset=utf-8,…")
```

### 添加属性（名称，表达式）[#](https://stylus.nodejs.cn/docs/bifs.html#add-propertyname-expr)

添加属性 `name`，并将给定的 `expr` 添加到最近的块。

例如：

```
something()
  add-property('bar', 1 2 3)
  s('bar')

body
  foo: something()
```

产量：

```
body {
  bar: 1 2 3;
  foo: bar;
}
```

接下来，"magic" `current-property` 局部变量开始发挥作用。该变量自动可供函数体使用，并包含具有当前属性名称和值的表达式。

例如，如果我们使用 `p()` 检查这个局部变量，我们会得到以下结果：

```
p(current-property)
// => "foo" (foo __CALL__ bar baz)

p(current-property[0])
// => "foo"

p(current-property[1])
// => foo __CALL__ bar baz
```

使用 `current-property`，我们可以进一步扩展示例，并使用新值和条件复制属性，以确保该函数仅在属性值中使用。

```
something(n)
  if current-property
    add-property(current-property[0], s('-webkit-something(%s)', n))
    add-property(current-property[0], s('-moz-something(%s)', n))
    s('something(%s)', n)
  else
    error('something() must be used within a property')

body {
  foo: something(15px) bar;
}
```

产量：

```
body {
  foo: -webkit-something(15px);
  foo: -moz-something(15px);
  foo: something(15px) bar;
}
```

如果你在上面的示例中注意到，`bar` 仅在初始调用中出现，因为我们返回了 `something(15px)`，所以它在表达式中保留在适当的位置，但是其他表达式不会考虑表达式的其余部分。

下面我们更强大的解决方案定义了一个名为 `replace()` 的函数，该函数克隆表达式以防止突变，将表达式的字符串值替换为另一个表达式，然后返回克隆的表达式。然后我们继续替换表达式中的 `__CALL__`，它表示对 `something()` 的循环调用。

```
replace(expr, str, val)
  expr = clone(expr)
  for e, i in expr
    if str == e
      expr[i] = val
  expr

something(n)
  if current-property
    val = current-property[1]
    webkit = replace(val, '__CALL__', s('-webkit-something(%s)', n))
    moz = replace(val, '__CALL__', s('-moz-something(%s)', n))
    add-property(current-property[0], webkit)
    add-property(current-property[0], moz)
    s('something(%s)', n)
  else
    error('something() must be used within a property')

body
  foo: something(5px) bar baz
```

产量：

```
body {
  foo: -webkit-something(5px) bar baz;
  foo: -moz-something(5px) bar baz;
  foo: something(5px) bar baz;
}
```

现在，我们的实现在调用它的属性和调用的位置方面都是完全透明的。

这个强大的概念有助于浏览器对函数调用（例如渐变）的透明支持。
