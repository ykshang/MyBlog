---
title: toRef、toRefs
createTime: 2025/08/06 00:10:16
permalink: /Vue/2m508n1t/
---

### `toRef` 和 `toRefs` 的定义与区别

#### 1. **`toRef`**

- **定义**：  
  为响应式对象（`reactive` 创建的对象）的**单个属性**创建一个 `ref`。该 `ref` 会与源属性**保持同步**（修改任一者，另一者会同步更新）。
- **语法**：
  ```typescript
  const ref = toRef(reactiveObject, "propertyName");
  ```
- **核心特点**：
  - 仅针对单个属性。
  - 如果源属性不存在，仍会创建一个可用的 `ref`（但值为 `undefined`）。
  - **不**触发视图更新（因为依赖原始响应式对象的依赖追踪）。

#### 2. **`toRefs`**

- **定义**：  
  将响应式对象（`reactive` 创建的对象）**所有属性**转换为普通对象，对象的每个属性都是 `ref`，且与源属性**保持同步**。
- **语法**：
  ```typescript
  const refsObject = toRefs(reactiveObject);
  ```
- **核心特点**：
  - 转换对象的所有属性。
  - 结果是一个普通对象，每个属性都是 `ref`。
  - 主要用于**解构/展开响应式对象时保持响应性**。
  - **不**触发视图更新（原因同 `toRef`）。

---

### 关键区别

| **特性**         | **`toRef`**                   | **`toRefs`**                            |
| ---------------- | ----------------------------- | --------------------------------------- |
| **作用对象**     | 单个属性                      | 整个对象的所有属性                      |
| **返回值**       | 单个 `ref` 对象               | 普通对象（每个属性是 `ref`）            |
| **主要用途**     | 提取特定属性并保持响应性      | 解构/展开整个对象并保持所有属性的响应性 |
| **源属性不存在** | 创建值为 `undefined` 的 `ref` | 不适用（转换所有现有属性）              |
| **典型场景**     | 传递单个属性到组合函数        | 从组合函数返回响应式对象的解构版本      |

---

### 示例代码

```vue
<script setup>
import { reactive, toRef, toRefs } from "vue";

const state = reactive({ count: 0, name: "Vue" });

// toRef: 提取单个属性
const countRef = toRef(state, "count");

// toRefs: 转换整个对象
const stateRefs = toRefs(state);

// 修改 toRef 会更新源对象
countRef.value++;
console.log(state.count); // 1

// 修改源对象会更新 toRefs
state.name = "Vue 3";
console.log(stateRefs.name.value); // "Vue 3"

// 解构后仍保持响应性（使用 toRefs）
const { count, name } = toRefs(state);
</script>
```

---

### 使用场景

- **`toRef`**：  
  需要将响应式对象的**某个属性**单独传递给函数或组件，并保持响应性。

  ```javascript
  // 将 state.count 作为 ref 传递
  useSomeFunction(toRef(state, "count"));
  ```

- **`toRefs`**：  
  从组合式函数返回响应式对象后，在组件中**解构**它时保持响应性。

  ```javascript
  // 组合式函数
  function useFeature() {
    const state = reactive({ x: 0, y: 0 });
    // ...逻辑
    return toRefs(state); // 解构 { x, y } 仍响应
  }

  // 组件中使用
  const { x, y } = useFeature(); // x 和 y 是 ref
  ```

---

### 注意事项

1. **不触发视图更新**：  
   修改 `toRef`/`toRefs` 创建的 `ref` **不会**触发视图更新（依赖原始 `reactive` 对象的依赖收集）。直接修改原始对象才会触发更新。
2. **仅适用于 `reactive` 对象**：  
   对普通对象使用 `toRef`/`toRefs` 无意义（不会自动创建响应性）。
3. **解构响应性**：  
   `toRefs` 是解决 `reactive` 对象直接解构丢失响应性的关键工具。

### 总结

| **函数** | **一句话总结**                              |
| -------- | ------------------------------------------- |
| `toRef`  | 为响应式对象的**单个属性**创建 `ref`。      |
| `toRefs` | 将响应式对象的**所有属性**转为 `ref` 对象。 |
