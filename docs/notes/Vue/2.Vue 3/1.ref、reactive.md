---
title: ref、reactive
createTime: 2025/08/05 11:04:50
permalink: /Vue/sshzeo62/
---

## 核心定义

### 1、`ref()` 响应式引用

创建对任意值（基本类型或对象）的响应式引用，通过 `.value` 属性访问实际值。

一般用于包装基本类型的数据，也可以用来包装对象。其实 `ref()` 就是对 `reactive()` 的包装。

```js
import { ref } from "vue";
// 基本类型
const count = ref(0);
console.log(count.value);
// 引用类型
const user = ref({ name: "John", age: 30 });
console.log(user.value);
// 替换值
count.value = 12;
user.value.name = "libao";
// 对象的完全替换
user.value = { name: "zhangsan", age: 40 };
```

::: tip 为什么需要通过 `.value` 来访问实际值
因为 proxy 只能代理包装类型，无法代理基本类型，所以需要把基本类型包装成一个对象 `{ value: 实际值 }`，然后代理这个对象。
:::

### 2、`reactive()` 响应式对象

创建深度响应式的对象代理（仅适用于对象、数组、Map、Set 等集合类型）

```javascript
import { reactive } from "vue";
// 对象
const state = reactive({
  count: 0,
  user: { name: "John" },
});
console.log(state.count);
// 数组
const list = reactive([1, 2, 3]);
```

我们不能直接整个修改 `reactive` 包装对象的值

```js
list = { name: "1" };
```

可以借助 `Object.asign()` 来拷贝对象

```js
Object.asign(list, { name: "1" });
```

## 核心区别对比

| **特性**         | `ref`                            | `reactive`                      |
| ---------------- | -------------------------------- | ------------------------------- |
| **支持数据类型** | 所有类型（基本类型 + 对象）      | 仅对象类型（对象/数组/Map/Set） |
| **访问方式**     | 通过 `.value` 访问               | 直接访问属性                    |
| **重新赋值**     | 支持完整替换（`ref.value = {}`） | 无法直接完整替换                |
| **响应式深度**   | 对象类型会使用 reactive          | 深层响应式（惰性代理）          |
| **TS 类型支持**  | 需显式泛型：`ref<Type>()`        | 自动类型推断                    |
| **解构响应性**   | 单个值保持响应性                 | 需 `toRefs` 包装来保持响应性    |
| **性能特点**     | 简单值内存开销小                 | 大型对象性能更优                |

```

```
