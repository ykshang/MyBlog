---
title: 开启 Gzip、Brotli 压缩
createTime: 2025/06/29 17:10:55
permalink: /Webpack/tan4smtf/
---

## 前端预压缩

Webpack 配置 Gzip、Brotli 压缩的方案，属于**前端预压缩**。这种在构建阶段生成 `.gz`、`.br` 文件的方式，与服务器实时压缩有本质区别。

### 预压缩的三大特征

#### 1、构建阶段完成压缩

在 `npm run build` 时生成 `.gz` 文件，而非用户请求时压缩

#### 2、产物包含压缩文件

输出目录中同时存在压缩文件和原始文件，例如 `main.js` 和 `main.js.gz`

```bash
dist/
├─ main.js
├─ main.js.gz  # 预压缩生成
├─ style.css
├─ style.css.gz
```

#### 3、服务器直接使用

Nginx 等服务器只需配置`gzip_static on`即可直接发送预压缩文件

```nginx
# Nginx配置
gzip_static on;  # 关键指令
gunzip on;       # 兼容不支持gzip的客户端
gzip off;        # 禁用动态压缩
```

### 与实时压缩的对比

传统的实时压缩方案，需要在服务器上配置 Gzip 模块，且每个请求都需要实时压缩。这样的操作比较考验服务器的配置和性能，而 Webpack 预压缩方案，在构建阶段一次性完成压缩，服务器无需额外配置，直接返回对应的 `.gz` 文件。

| 特性     | 预压缩                   | 服务器实时压缩           |
| -------- | ------------------------ | ------------------------ |
| 压缩时机 | 构建阶段                 | 请求时实时压缩           |
| CPU 消耗 | 构建时一次性消耗         | 每次请求消耗 CPU         |
| 响应速度 | 极快（直接发送静态文件） | 较慢（需要实时压缩）     |
| 适用场景 | 静态资源                 | 动态 API 响应            |
| 部署要求 | 需上传.gz 文件           | 只需服务器启用 gzip 模块 |

## 开启 Gzip、Brotli 压缩

### 安装 compression-webpack-plugin 插件

```bash
npm install compression-webpack-plugin@^9.0.0 --save-dev
```

### 完整 webpack 配置示例

```javascript title="webpack.config.js" :collapsed-lines=10
const CompressionPlugin = require("compression-webpack-plugin");

module.exports = {
  plugins: [
    // Gzip 压缩
    new CompressionPlugin({
      filename: "[path][base].gz", // 输出文件名模式
      algorithm: "gzip", // 使用gzip算法
      test: /\.(js|css|html|json|svg|txt|eot|otf|ttf|woff|woff2)$/, // 压缩文件类型
      threshold: 10240, // 只压缩大于10KB的文件
      minRatio: 0.8, // 只有压缩率优于80%才会压缩
      deleteOriginalAssets: false, // 是否删除原始文件
      cache: true, // 启用缓存
      compressionOptions: {
        level: 9, // 最高压缩级别
      },
    }),

    // Brotli 压缩（需 Node.js ≥ v11.7.0）
    new CompressionPlugin({
      filename: "[path][base].br",
      algorithm: "brotliCompress", // 使用 Node.js 原生 Brotli
      test: /\.(js|css|html|svg|json)$/,
      threshold: 50 * 1024, // 只压缩 >50KB 的文件
      minRatio: 0.8,
      compressionOptions: {
        level: 11, // Brotli 压缩级别 (1-11)
        params: {
          // 高级参数（可选）
          [zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT, // 文本模式
          [zlib.constants.BROTLI_PARAM_QUALITY]: 11, // 等同 level
        },
      },
    }),
  ],
};
```

| 参数                   | 类型            | 默认值            | 说明                                         |
| ---------------------- | --------------- | ----------------- | -------------------------------------------- |
| `filename`             | String/Function | `[path][base].gz` | 生成的压缩文件名模式                         |
| `algorithm`            | String/Function | `gzip`            | 压缩算法，支持 `gzip`/`deflate`/`deflateRaw` |
| `test`                 | RegExp/Array    | 匹配所有文件      | 指定需要压缩的文件类型                       |
| `threshold`            | Number          | `0`               | 文件大小阈值（字节），大于此值才压缩         |
| `minRatio`             | Number          | `0.8`             | 压缩比阈值，小于此值才压缩                   |
| `deleteOriginalAssets` | Boolean         | `false`           | 是否删除原始文件                             |
| `cache`                | Boolean/String  | `false`           | 启用缓存或指定缓存目录                       |
| `compressionOptions`   | Object          | `{}`              | 传递给 zlib 的选项                           |

### Nginx 服务器

Nginx 服务器配置需要配置的参数

```nginx
# 优先匹配br
brotli off; # 禁用动态压缩
brotli_static on;  # 优先使用预压缩文件（如果有）

# 优先匹配 gzip
gzip off; # 禁用动态压缩
gzip_static on;  # 优先使用预压缩文件（如果有）
gunzip on; # 兼容不支持gzip的客户端
gzip_vary on; # 确保响应头包含 Vary: Accept-Encoding
```

### Node.js 作为服务器

例如使用 Express 作为服务器，手动实现需要注意以下几点：

1. 需要根据请求头里的 `Accept-Encoding` 字段，判断浏览器支持的压缩格式。
2. 如果浏览器不支持压缩，中间件不做任何处理，直接返回源文件。
3. 如果浏览器支持压缩文件，则根据请求头返回对应的压缩文件，优先返回 `.br`，其实选择 `.gz`。
4. 需要根据对应压缩文件的内容，设置`Content-Encoding`、`Content-Type` 响应头。告知浏览器以什么样的格式去读取。

```js :collapsed-lines=10
const express = require("express");
const path = require("path");
const fs = require("fs");

const app = express();
const staticDir = path.join(__dirname, "dist");

// 中间件：检查并返回预压缩文件
app.use((req, res, next) => {
  const acceptEncoding = req.headers["accept-encoding"] || "";
  const filePath = path.join(staticDir, req.path);

  // 检查原始文件是否存在
  if (!fs.existsSync(filePath)) return next();

  // 优先返回 Brotli
  if (acceptEncoding.includes("br") && fs.existsSync(`${filePath}.br`)) {
    req.url = `${req.url}.br`;
    res.set("Content-Encoding", "br");
  }
  // 次优先返回 Gzip
  else if (acceptEncoding.includes("gzip") && fs.existsSync(`${filePath}.gz`)) {
    req.url = `${req.url}.gz`;
    res.set("Content-Encoding", "gzip");
  }

  next();
});

// 静态文件服务
app.use(
  express.static(staticDir, {
    setHeaders: (res, filePath) => {
      // 修正压缩文件的 Content-Type（移除 .gz/.br 后缀）
      if (filePath.endsWith(".br") || filePath.endsWith(".gz")) {
        const originalExt = path.extname(filePath.replace(/\.(br|gz)$/, ""));
        res.set("Content-Type", getMimeType(originalExt));
      }
    },
  })
);

// 获取 MIME 类型
function getMimeType(ext) {
  const types = {
    ".js": "application/javascript",
    ".css": "text/css",
    ".html": "text/html",
    ".json": "application/json",
  };
  return types[ext] || "text/plain";
}

app.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```

或者使用中间件 `express-static-gzip` 实现。

```js :collapsed-lines=10
const express = require("express");
const expressStaticGzip = require("express-static-gzip");

const app = express();

// 自动处理 .gz 和 .br 文件
app.use(
  "/",
  expressStaticGzip("dist", {
    enableBrotli: true, // 启用 Brotli
    orderPreference: ["br"], // 优先返回 Brotli
    serveStatic: {
      maxAge: "1y", // 缓存一年
      cacheControl: true,
      setHeaders: (res, path) => {
        // 可自定义响应头
      },
    },
  })
);

app.listen(3000);
```

### 压缩中间件参数详解

| 参数        | 类型          | 默认值                       | 说明                              |
| ----------- | ------------- | ---------------------------- | --------------------------------- |
| `level`     | Integer       | `-1` (Z_DEFAULT_COMPRESSION) | 压缩级别(0-9)                     |
| `memLevel`  | Integer       | `8`                          | 内存使用级别(1-9)                 |
| `strategy`  | Integer       | `0` (Z_DEFAULT_STRATEGY)     | 压缩策略                          |
| `threshold` | Number/String | `0`                          | 最小压缩大小(字节或字符串如'1kb') |
| `filter`    | Function      | 默认过滤文本类型             | 自定义压缩过滤函数                |

## Nginx 服务器详细配置

### 完整 Nginx Gzip 配置

```nginx
http {
  # 基本Gzip配置
  gzip on;
  gzip_http_version 1.1;
  gzip_comp_level 6;
  gzip_min_length 1024;
  gzip_proxied any;
  gzip_vary on;

  # 压缩类型配置
  gzip_types
    text/plain
    text/css
    text/javascript
    text/xml
    application/javascript
    application/x-javascript
    application/json
    application/xml
    application/xml+rss
    application/vnd.ms-fontobject
    application/x-font-ttf
    font/opentype
    image/svg+xml;

  # 预压缩文件配置
  gzip_static on;
  gunzip on;

  # 禁用特定浏览器的Gzip
  gzip_disable "MSIE [1-6]\.";

  # 其他优化参数
  gzip_buffers 16 8k;
}
```

### Nginx 配置参数详解

| 指令                | 值类型        | 默认值      | 说明                                    |
| ------------------- | ------------- | ----------- | --------------------------------------- |
| `gzip`              | on/off        | off         | 启用/禁用 Gzip 压缩                     |
| `gzip_http_version` | 1.0/1.1       | 1.1         | 最小 HTTP 版本要求                      |
| `gzip_comp_level`   | 1-9           | 1           | 压缩级别(越高压缩率越大但 CPU 消耗越高) |
| `gzip_min_length`   | 字节数        | 20          | 最小压缩文件大小                        |
| `gzip_proxied`      | 多种选项      | off         | 对代理请求的压缩行为                    |
| `gzip_vary`         | on/off        | off         | 是否添加"Vary: Accept-Encoding"头       |
| `gzip_types`        | MIME 类型列表 | text/html   | 指定压缩的文件类型                      |
| `gzip_static`       | on/off/always | off         | 优先使用预压缩文件(.gz)                 |
| `gunzip`            | on/off        | off         | 为不支持 Gzip 的客户端解压              |
| `gzip_buffers`      | number size   | 32 4k/16 8k | 压缩缓冲区数量和大小                    |

### 推荐的 Nginx 压缩类型

```nginx
gzip_types
  text/plain
  text/css
  text/javascript
  text/xml
  text/x-component
  application/javascript
  application/x-javascript
  application/json
  application/xml
  application/xml+rss
  application/xhtml+xml
  application/rss+xml
  application/atom+xml
  application/vnd.ms-fontobject
  application/x-font-ttf
  application/x-font-opentype
  application/x-font-truetype
  font/eot
  font/opentype
  font/otf
  image/svg+xml
  image/x-icon;
```

## 验证 Gzip 是否生效

### 使用 curl 命令验证

```bash
curl -H "Accept-Encoding: gzip" -I http://yourserver.com/main.js

# 预期输出应包含：
# Content-Encoding: gzip
# Vary: Accept-Encoding
```

### 浏览器开发者工具检查

1. 打开 Chrome 开发者工具(F12)
2. 切换到 Network 标签
3. 刷新页面
4. 点击任意资源文件，查看响应头：
   - 应有`content-encoding: gzip`
   - 比较`Content-Length`和资源实际大小

### 文件大小对比检查

```bash
# 原始文件大小
ls -lh dist/main.js

# Gzip压缩后大小
ls -lh dist/main.js.gz
```

## 性能优化建议

1. **静态文件**：

   - 使用 Webpack 预生成.gz 文件
   - 配置 Nginx 优先使用预压缩文件(`gzip_static on`)

2. **动态内容**：

   - 使用 Node.js 中间件实时压缩
   - 设置适当的压缩级别(通常 6 是最佳平衡点)

3. **缓存配置**：

   ```nginx
   location ~* \.(js|css|html|json)$ {
     expires 1y;
     add_header Cache-Control "public, immutable";
     add_header Vary "Accept-Encoding";
   }
   ```

4. **监控与调优**：
   - 监控服务器 CPU 使用率
   - 根据实际流量调整`gzip_comp_level`
   - 定期检查压缩率是否正常
