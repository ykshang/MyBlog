---
title: 代码拆分
createTime: 2025/03/15 14:24:21
permalink: /Webpack/dwuygr9t/
---

Webpack 的 **代码拆分（Code Splitting）** 是一种将代码分割成多个 bundle 或 chunk 的技术，目的是减少初始加载时间，优化应用性能。

Webpack 打包代码时会根据 chunk 来将所有 js 文件打包到一个文件中，这样打包出来的文件可能体积很大。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。

因此我们需要基于一定策略和维度来分割代码。以下是 Webpack 代码拆分的核心概念和实现方式：

::: tip 总结

- 在 webpack 配置文件中启用并**配置代码分割**策略，设置合适的参数
- 可以使用**魔法注释**告诉 webpack 输出文件的名字，有助于我们进行打包分析。
- **Css 文件提取：** 使用`MiniCssExtractPlugin `将 css 从 html 里提取出来
- **提取公共依赖** splitChunks 去指定模块或者路径
- **提取重复代码** splitChunks 定义被复用次数

:::

## 拆分策略

- 多入口拆分：合理拆分业务代码，配置多个入口。
- 公共代码提取：主要指 `common`、`util`、`layout`。
- Runtime 文件：runtime 代码是 webpack 用来处理模块依赖的辅助代码、胶水代码。
- 第三方依赖（Vendor）：其实就是把 `node_module` 拆分成多个 Vendor，把诸如 Element-UI、Vue、Loadash 等体积较大的包拆分出来单独打包。
- 魔法注释：Webpack 提供魔法注释 `/* webpackChunkName: "name" */`，我们可以用来标记 `import()` 引入的模块，这样可以给代码拆分后的文件起一个自定义的名称，一般用来标记路由组件、公共组件、第三方库等。
- 路由

## 核心目标

- **减少首屏加载时间**：拆分关键代码与非关键代码。
- **按需加载**：只在需要时加载特定的组件、路由或者功能模块，减少初始加载时间。
- **并行加载**：利用浏览器多线程下载多个小文件。
- **将代码拆分成多个文件**：将应用代码分割成多个 bundle 或 chunk，而不是打包成一个巨大的文件。
- **提高缓存利用率**：通过拆分，尽量减小代码的影响范围，利用浏览器缓存提升性能。

## 场景策略选择

| **场景**              | **推荐策略**                            |
| --------------------- | --------------------------------------- |
| 多页面应用（MPA）     | 多入口 + `SplitChunksPlugin`            |
| 单页面应用（SPA）路由 | 动态导入 + 魔法注释                     |
| 第三方库优化          | `SplitChunksPlugin` 提取 `node_modules` |
| 公共工具函数          | 手动分离为独立入口或 `cacheGroups`      |
| 非首屏组件（如弹窗）  | 动态导入 + `webpackPrefetch`            |

## 拆分策略

### 1. 多入口拆分（Entry Points）

通过配置多个入口文件，手动分离代码。  
**适用场景**：多页面应用（MPA）或明确需要分离的独立模块。

```javascript
// webpack.config.js
module.exports = {
  entry: {
    app: "./src/app.js",
    vendor: ["react", "react-dom"], // 第三方依赖单独打包
  },
};
```

**缺点**：重复依赖需手动去重（需配合 `SplitChunksPlugin`）。

### 2. 动态导入（Dynamic Imports）

使用 `import()` 语法实现按需加载（基于 Promise）。  
**适用场景**：路由懒加载、组件懒加载。

```javascript
// 动态加载模块
button.addEventListener("click", () => {
  import("./module.js").then((module) => {
    module.doSomething();
  });
});

// React 路由懒加载
const Home = React.lazy(() => import("./Home"));
```

**输出效果**：

- 生成独立的 chunk 文件（如 `1.bundle.js`）。
- 默认通过 JSONP 动态插入 `<script>` 标签加载。

### 3. SplitChunksPlugin（公共依赖拆分）

自动提取公共依赖（如 `node_modules` 或重复代码）。  
**适用场景**：优化重复依赖和缓存。

```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: "all", // 对所有 chunks 优化（包括异步和同步）
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/, // 拆分 node_modules
          name: "vendors",
          priority: 10, // 优先级
        },
        common: {
          minChunks: 2, // 被至少 2 个 chunk 引用的模块
          name: "common",
          priority: 5,
        },
      },
    },
  },
};
```

**输出效果**：

- `vendors~app~home.js`（第三方库）
- `common~app~home.js`（公共模块）

### 4. 魔法注释（Magic Comments）

通过注释控制动态导入的 chunk 名称和行为。

```javascript
import(
  /* webpackChunkName: "lodash" */
  /* webpackPrefetch: true */ // 预加载（空闲时提前加载）
  /* webpackPreload: true */ // 预获取（与父 chunk 并行加载）
  "lodash"
);
```

**常用注释**：

- `webpackChunkName`：定义 chunk 名称。
- `webpackPrefetch`：资源空闲时预加载（适用于未来可能需要的模块）。
- `webpackPreload`：与当前 chunk 并行加载（适用于关键依赖）。

### 5. CSS 代码提取

通过 `mini-css-extract-plugin` 分离 CSS 文件。

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  plugins: [new MiniCssExtractPlugin({ filename: "[name].[contenthash].css" })],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      },
    ],
  },
};
```

**输出效果**：

- 生成独立的 `main.css` 文件，避免 CSS 内联到 JS 中。

## 优化技巧

### 1、分析打包结果

使用 `webpack-bundle-analyzer` 可视化依赖体积：

```bash
npm install --save-dev webpack-bundle-analyzer
```

```javascript
const BundleAnalyzerPlugin =
  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
module.exports = {
  plugins: [new BundleAnalyzerPlugin()],
};
```

### 2、提高缓存利用率

为稳定依赖（如 `vendor`）设置 `contenthash`，尽量减小缓存文件的变化范围，有效的提高浏览器缓存利用率。

```javascript
output: {
  filename: '[name].[contenthash:8].js',
  chunkFilename: '[name].[contenthash:8].chunk.js',
},
```

### 按需加载 Polyfill

避免全量引入 `babel-polyfill`，改用 `@babel/preset-env` + `useBuiltIns: 'usage'`。

## 注意事项

- **避免过度拆分**：HTTP/2 多路复用下，过多小文件可能增加请求开销。
- **同步与异步 chunk**：`SplitChunksPlugin` 需配置 `chunks: 'all'` 才能覆盖异步 chunk。
- **服务端配置**：确保支持 chunk 文件的按需加载（如 Nginx 正确配置 `try_files`）。
- **合理配置缓存**：确保公共代码和第三方库的 chunk 能够被浏览器缓存。
- **处理加载状态**：动态加载组件时，需提供加载指示（如加载动画）。

通过合理组合上述策略，可显著提升应用加载速度和运行效率。
